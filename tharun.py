# -*- coding: utf-8 -*-
"""tharun.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14xKDKzL9vS9itk1cO0-wO0taI3cbjjE_
"""

!pip install kneed

import warnings
warnings.filterwarnings("ignore")
import pandas as pd
import numpy as np
import wbgapi as wb
import errors, cluster_tools
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
import seaborn as sns
from sklearn.cluster import KMeans
from scipy.optimize import curve_fit
from sklearn.preprocessing import MinMaxScaler

cdcntr = ['IND','VNM','GBR']    # country codes
ind=["NY.GDP.PCAP.PP.CD","EN.ATM.CO2E.KT"]   # World bank indicators
mng=["GDP Per Capita","CO2 Emission"]    # indicator names

wbdtgdp = wb.data.DataFrame("NY.GDP.PCAP.PP.CD", cdcntr, mrv=60).T    # read data and transpose to get the dataframe by country GDP PER CAPITA
wbdtgdp=wbdtgdp.fillna(wbdtgdp.mean())    # cleaning missing values by mean
wbdtgdp.head()

wbdtco2  = wb.data.DataFrame("EN.ATM.CO2E.KT", cdcntr, mrv=60).T  # read data and transpose to get the dataframe by country CO2 Emission
wbdtco2=wbdtco2.fillna(wbdtco2.mean())    # cleaning missing values by mean
wbdtco2.head()

def linechart(df, nm, ccd):   # visulize line chart
    plt.figure(figsize=(8,4))    # plot figure size
    plt.title('{} of Selected Countries by Year'.format(nm))   # plot title
    plt.plot(df[ccd[0]],"#F67280",label=ccd[0])    # line chart for the country code IND
    plt.plot(df[ccd[1]],"#FFFF33",label=ccd[1])    # line chart for the country code VNM
    plt.plot(df[ccd[2]],"#00FA9A",label=ccd[2])    # line chart for the country code GBR
    plt.xlabel("Year")    # x-label
    plt.xticks(rotation=90)   # rotating x-ticks (label)
    plt.ylabel("{}".format(nm))   # y-label
    plt.legend()    # set legen default to beft position
    plt.show()

dts=[wbdtgdp,wbdtco2]
for d in range(len(dts)):
    linechart(dts[d], mng[d], cdcntr)

for d in range(len(dts)):
    cluster_tools.map_corr(dts[d])   # Call map_error function to plot correlation

scldfs=[]
mns=[]
mxs=[]
for d in range(len(dts)):
    res=cluster_tools.scaler(dts[d])   # call scalar method to normalize data
    scldfs.append(res[0])   # store normaliozed data
    mns.append(res[1])   # store the minimum value
    mxs.append(res[2])   # store the maximum value
print(scldfs[0].head(),"\n")
print(scldfs[1].head())

bckarr=[]
for s in range(len(scldfs)):
    bckarr.append(cluster_tools.backscale(np.array(scldfs[s]),mns[s],mxs[s]))    # backscaling
print(bckarr[0],"\n")
print(bckarr[1])

cluster_tools.get_diff_entries(scldfs[0],scldfs[1],'GBR')

"""## Clustering"""

wss = []
for i in range(1, 21):    # checking best k-value by employing cluster values 1-21
    kmeans = KMeans(n_clusters=i, init='k-means++', max_iter=200,  random_state=10)    # crerate k-means model
    kmeans.fit(scldfs[0])   # fit moidel
    wss.append(kmeans.inertia_)
plt.figure(figsize=(7,4))   # plot figure
plt.title('Finding Optimum Cluster')   # plot title
plt.plot(range(1, 21), wss,"g--")
plt.plot(range(1, 21), wss,"vb")
plt.xlabel('Number of clusters')    # x-label
plt.ylabel('Inertia')   # y-label
plt.show()

kmeans = KMeans(n_clusters=3, max_iter=100, n_init=50, random_state=0)   # appltying final k-means with the final cluster value
clus_model1 = kmeans.fit(scldfs[0])   # training k-means model with GDP Per Capita data
nlst=[]
for i in clus_model1.labels_:
    if i==0:
        nlst.append(wbdtgdp.columns[0])    # set couny name with code IND
    elif i==1:
        nlst.append(wbdtgdp.columns[1])    # set couny name with code VNM
    elif i==2:
        nlst.append(wbdtgdp.columns[2])    # set couny name with code GBR
df=pd.DataFrame(scldfs[0],columns=wbdtgdp.columns)
plt.figure(figsize=(7,4))
plt.title('Cluster Visualization')    # visulizing clusters
sns.scatterplot(data=df, x=wbdtgdp.columns[2], y=wbdtgdp.columns[0], hue=nlst,palette="gist_yarg")
plt.scatter(clus_model1.cluster_centers_[:,0], clus_model1.cluster_centers_[:,1], 
            marker="x", c="m", s=80, label="centroids")
plt.legend()     # set legen default to best position
plt.show()

"""## Curve Fitting"""

def exponent(x, a, b, c):
    return a * np.exp(-b * x) + c

y = exponent(scldfs[1].values[:,1], 2.2, 0.4, 0.9)   # call function for computation
rng = np.random.default_rng()    # Setting range for curve fiting
try:
    y_noise = 0.3 * rng.normal(size=scldfs[1].values[:,1].size)  # determining errors 
    ydata = y + y_noise     # getting prediction
    popt, pcov = curve_fit(exponent, scldfs[1].values[:,1], ydata)     # apply curve fitting
except:
    y_noise = round(np.random.random(),2) * rng.normal(size=scldfs[1].values[:,1].size)  # determining errors 
    ydata = y + y_noise     # getting prediction
    popt, pcov = curve_fit(exponent, scldfs[1].values[:,1], ydata)     # apply curve fitting
plt.figure(figsize=(12,6))
plt.title('Curve Fiting Results')   # plot title
plt.plot(scldfs[1].values[:,0], ydata, 'rx', label='data')
plt.plot(scldfs[1].values[:,0], exponent(scldfs[1].values[:,0], *popt), 'b--',label='Best fit: a=%5.3f, b=%5.3f, c=%5.3f' % tuple(popt))
plt.xlabel('x')    # x-label
plt.ylabel('y')   # y-label
plt.legend()     # set legen default to best position
plt.show()



